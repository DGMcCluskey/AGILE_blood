---
title: "Untitled"
format: html
---

## Sub-clustering analysis of the AGILE blood data
### this script relies on the "agile_blood_clustered" object from the initial analysis to be loaded in first

```{r}
library(CATALYST)
library(harmony)
library(cowplot)
library(flowCore)
library(scater)
library(SingleCellExperiment)
library(viridis)
library(RColorBrewer)
library(ggforce)
library(ggplot2)
library(ggrepel)
library(ggsci)
library(data.table)
library(emmeans)
library(dplyr)
library(tidyr)
library(ggsignif)
library(rstatix)
library(multcomp)
library(scales)
library(ggthemes)
library(slingshot)
library(ggbeeswarm)
library(ggbreak)
library(DescTools)
library(pak)
library(gghighlight)
library(scattermore)
library(clustree)
library(gridExtra)
library(patchwork)
library(ggbump)
library(stringr)
library(grid)
library(lme4)
library(emmeans)
library(purrr)
library(randomcoloR)
```
```{r}
setwd("c:/Users/dan_m/OneDrive - University College London/UCL_Senior_Research_Fellow/AGILE/Blood")
```

## read in the object and then move to a subclustering folder where object and graphs will be saved
```{r}
sce <- readRDS("agile_blood_annotated.rds")
setwd("c:/Users/dan_m/OneDrive - University College London/UCL_Senior_Research_Fellow/AGILE/Blood/sub_clustering")
```

## the rationale of subclustering is to identify more specific cell subsets
## to perform a meaningful subclustering i will exclude the neutrophils from analysis and cluster again in attempt to pull apart T cell subsets for example
```{r}
sce <- filterSCE(sce, !labels %in% "neutrophil")
```

## run clustering
```{r}
set.seed(61)
sce <- CATALYST::cluster(sce, features = NULL, xdim = 10, ydim = 10, maxK = 30, verbose = T, seed = 61)

delta <- delta_area(sce)
delta <- delta$data
ggplot(delta, aes(x = k, y = y))+geom_point(size = 5)+geom_line(linewidth = 1.5)+
  theme_classic()+
  theme(axis.text = element_text(colour = "black", size = 18), 
        axis.title = element_text(size = 18, colour = "black"))+
  xlab("K (number of clusters)")+ylab("Relative change in \n area under CDF curve")
```

## create umap
```{r}
sce <- runDR(sce, "UMAP", features = NULL)
#saveRDS(sce, file= "agile_blood_subclustered.rds", compress = F)
```

```{r}
sce <- readRDS("agile_blood_subclustered.rds")
```
## inspect the umaps based on metadata and then clustering resolution
### this code is all the same as the initial clustering script so has been put into one code chunk for brevity
```{r}
variables <- c("donor", "treatment", "time")
umaps <- list()
for (i in variables) {
umaps[[i]] <- plotDR(sce, "UMAP", color_by = i)+theme_bw()+
    geom_scattermore()
} 
p1 <- plot_grid(umaps$donor, umaps$treatment, umaps$time)
p1

res <- c("meta10", "meta12", "meta15", "meta20")
umaps <- list()

for (i in res) {
umaps[[i]] <- plotDR(sce, "UMAP", color_by = i)+theme_bw()+
    geom_scattermore()
} 

p2 <- plot_grid(umaps$meta10, umaps$meta12, umaps$meta15, umaps$meta20)
p2

ggsave(plot = p2, filename = "umaps_resolution_comparison.png", dpi = 500,
height = 6, width = 16)
```

## i also plot the expression of all markers in the umap. whilst this is computationally intensive and takes a while, it is worth it as it allows us to see if a marker is expressed across clusters or is distinct to one cluster
```{r}
markers.input <- rownames(sce)
p2 <- plotDR(sce, color_by = markers.input)+theme_bw()
ggsave(plot = p2, filename = "umap_all_markers.png", dpi = 500,
height = 16, width = 16, bg = "white")
```

## plotting specific k of interest in multiple ways to QC clusters
```{r}
p1 <- plotDR(sce, color_by = "meta20")+theme_bw()
p1
p2 <- plotDR(sce, color_by = "meta20")+facet_wrap(~meta20)+theme_bw()
p2

p3 <- plotAbundances(sce, k = "meta20", by = "cluster_id", group_by="donor")
p3

p4 <- plotExprHeatmap(sce, k = "meta20", by = "cluster_id", bars = TRUE, perc = TRUE)
p4

combo <- p1+theme(legend.position="none")+p2+p3+theme(legend.position="none")+plot_layout(ncol=3)
ggsave(combo, filename="subclustering_qc.png", dpi=500, height=10, width = 20)
```

## filtering
### there a number of tiny clusters (below 1% of cells, even with neuts removed), suggesting they may be called as a cluster due to high expression of only one marker
### most of these tiny clusters are also spatially spread throughout the plot
### i'm confident these are cells that have picked up multiple antibodies, have abnormal expression and are not meaningful
### i will filter out these clusters
## made an exception for cluster 10, as this has reasoable foxp3, so might be a (sverely underrepresented) treg population
```{r}
sce <- filterSCE(sce, k = "meta20", cluster_id %in% c("1", "3", "5", "6", "9", "10", "11",
"14", "16", "17", "19"))
```

## annotation
### make a heatmap again with final clusters, to best visualise marker split
```{r}
p1 <- plotDR(sce, color_by = "meta20")+theme_bw()
p1
p2 <- plotExprHeatmap(sce, k = "meta20", by = "cluster_id", bars = TRUE, perc = TRUE)
p2
```

### make and apply the labels
```{r}
merging.table <- data.frame("original" = c(1,3,5,6,9,10,11,14,16,17,19), 
"labels" = c("CD4+T", "Memory CD8+T", "Naive CD8+T", "T", "DC", "Treg", "Non_classical_mono", "NK", "Intermediate_mono", "Classical_mono", "B"))

sce <- mergeClusters(sce, k = "meta20", table = merging.table, id = "labels", overwrite = T)

sce$labels <- cluster_ids(sce, k = "labels")
```

## save annotated object
```{r}
saveRDS(sce, file="agile_blood_subclustered_annotated.rds", compress=F)
sce <- readRDS("agile_blood_subclustered_annotated.rds")
```

## extract data for plotting
### dataframe is more versatile than the singlecellexperiment
```{r}
sce$k20 <- cluster_ids(sce, "meta20")

ex <- assay(sce, "exprs")
neut.data <- data.frame(t(ex), sample_id = sce$sample_id, donor = sce$donor, 
                        treatment = sce$treatment, time = sce$time, 
                        k20 = sce$k20, labels = sce$labels)
#add umap dimensions
umap.coords <- data.frame(reducedDim(sce, "UMAP"))
neut.data$UMAP_1 <- umap.coords$UMAP1
neut.data$UMAP_2 <- umap.coords$UMAP2
neut.data$labels <- factor(neut.data$labels, levels =c("CD4+T", "Treg", "Naive CD8+T", "Memory CD8+T", "T", "NK", "B",
"Classical_mono", "Intermediate_mono", "Non_classical_mono", "DC", "neutrophil"))
```

## annotated umaps
```{r}
cluster_palette <- c("seagreen3", "darkgreen", "indianred2", "red", "darkred", "darkorchid2", "orange",
  "steelblue2", "blue", "cyan4", "cyan1")
label_data <- neut.data %>%
  group_by(labels) %>%
  summarise(UMAP_1 = median(UMAP_1), UMAP_2 = median(UMAP_2), .groups = "drop")

plot1 <-ggplot(neut.data, aes(x=UMAP_1,y=UMAP_2,colour=labels))+geom_scattermore()+
  theme_half_open()+
  scale_colour_manual(values = cluster_palette)+
    geom_label_repel(data=label_data, aes(label=labels, fill = labels), colour = "white",
    size = 5, fontface = "bold", label.size = 1)+
    scale_fill_manual(values = cluster_palette)+
    theme(legend.position = "none")
plot1

plot2 <- ggplot(neut.data, aes(x=UMAP_1,y=UMAP_2,colour=treatment))+geom_scattermore()+
  theme_half_open()+
  scale_colour_manual(values = c("mediumseagreen", "darkorchid2"))+
  theme(
    legend.position = "right",
    legend.title = element_text(size = 16),
    legend.text = element_text(size = 14)
  )

plot3 <- ggplot(neut.data, aes(x=UMAP_1,y=UMAP_2,colour=time))+geom_scattermore()+
  theme_half_open()+
  scale_colour_manual(values = c("black", "grey50", "darkred", "red", "darkorchid2", "steelblue2", "blue"))+
  theme(
    legend.position = "right",
    legend.title = element_text(size = 16),
    legend.text = element_text(size = 14)
  )+guides(colour=guide_legend(ncol=2))

random_palette <- distinctColorPalette(18)
plot4 <- ggplot(neut.data, aes(x=UMAP_1,y=UMAP_2,colour=donor))+geom_scattermore()+
  theme_half_open()+
  scale_colour_manual(values=random_palette)+
  theme(
    legend.position = "right",
    legend.title = element_text(size = 16),
    legend.text = element_text(size = 10)
  )+guides(colour=guide_legend(ncol=2))

combo <- plot1 + (plot2 / plot3 / plot4)+plot_layout(, ncol = 2,widths = c(3, 1))
combo
ggsave(plot=combo,filename="annotated_umaps.png", dpi=500,height=10,width=18,bg="white")
```

## heatmap and violin plots to accompany annotated umap
## easiest way to do this is to generate a heatmap through catalysts' own function and then extract and plot this with pheatmap
### note the subsetting of the "hm" - this is me choosing the markers for the hetamp (e.g. dont need neut markers, or markers that dont distinguish populations)
```{r}
markers <- rownames(sce)
hm <- plotExprHeatmap(sce, features = markers, 
by = "cluster_id", k = "labels", bars = T, perc = T, scale = "last")

hm <- hm@matrix
hm <- hm[, c(4,5,6,7,10,16,19,21,22,24,26,30)]
hm2 <- pheatmap::pheatmap(hm, scale = "none", color = rev(hcl.colors(100, "RdYlBu")), border_color = "black",cluster_cols = T, cluster_rows = T, treeheight_col = 0, treeheight_row=10, cellheight = 20, cellwidth = 20)

ggsave(plot=hm2,filename="key_marker_heatmap.png", dpi=500,height=5,width=8,bg="white")

marker_df <- neut.data[, c(4,5,6,7,10,16,19,21,22,24,26,30,37)]
marker_df <- pivot_longer(marker_df, names_to = "marker", values_to = "expression", cols = 1:12)

p.violin <- ggplot(marker_df, aes(x = labels, y = expression, fill = labels))+geom_violin(scale = "width", trim = T)+
  facet_grid(rows = vars(marker), scales = "free", switch = "y")+theme_cowplot()+
  scale_y_continuous(expand = c(0, 0), position="right", labels = function(x)
    c(rep(x = "", times = length(x)-2), x[length(x) - 1], ""))+
  theme(legend.position = "none", panel.spacing = unit(0, "lines"),
        plot.title = element_text(hjust = 0.5),
        panel.background = element_rect(fill = NA, color = "black"),
        strip.background = element_blank(),
        strip.text = element_text(face = "bold"),
        strip.text.y.left = element_text(angle = 0, size = 14))+
  theme(axis.text.x = element_text(size = 14, colour = "black", angle = 45, hjust = 1))+
  xlab(NULL)+
  scale_fill_manual(values=cluster_palette)
p.violin
ggsave(plot=p.violin, filename = "violin_expression.png", dpi = 500,
height = 14, width = 6, bg = "white")
```

## cluster proportions
### a few samples have a 4hr time, these will be called 6h here for analysis sake, but acknowledged throughout
### before i run differential abundance, i want to just see the proportions of each cluster in total across the dataset
```{r}
neut.data$time_new <- factor(neut.data$time, levels = c("-72h", "0h", "4h", "6h", "24h", "48h", "72h"),
labels = c("-72h", "0h", "6h", "6h", "24h", "48h", "72h"))
proportions <- neut.data %>% group_by(labels, donor) %>% dplyr::count(labels,donor)
proportions <- pivot_wider(proportions, names_from = labels, values_from = n)
proportions[is.na(proportions)] <- 0
proportions$total = rowSums(proportions[, c(2:12)])
proportions <- pivot_longer(proportions, names_to = "cluster", values_to = "number", 2:12)
proportions$prop <- (proportions$number/proportions$total)*100
proportions$cluster <- factor(proportions$cluster, 
levels =c("CD4+T", "Treg", "Naive CD8+T", "Memory CD8+T", "T", "NK", "B",
"Classical_mono", "Intermediate_mono", "Non_classical_mono", "DC", "neutrophil"))
p1 <- ggplot(proportions, aes(x = donor, y = prop, fill = cluster))+
  geom_col()+theme_bw()+
  theme(axis.text.y = element_text(size = 12, colour = "black"))+
  theme(axis.text.x = element_text(size = 8, colour = "black", angle =45, hjust=1))+
  theme(strip.text=element_text(size = 14, colour = "black", face = "bold"))+
  theme(axis.title=element_text(size=16, colour ="black"))+
  scale_fill_manual(values = cluster_palette)+
  scale_y_continuous(expand = c(0,0))+
  labs(x = "Donor", y = "% of whole blood", fill = NULL)+
  theme(legend.text = element_text(size = 14))

p1
ggsave(plot=p1, filename = "cluster_proportions_barplot.png", dpi = 500, height = 12, width = 6)
```

## differential abundance analysis
### set data up for mixed-effects model
### here im getting counts per cluster, total cells per sample, then a summary
### before that i need to make sure every cluster is present for every donor, even if there are 0 cells (e.g. in tregs) to ensure downstream the analysis works
```{r}
# Get unique clusters and samples
all_combos <- expand.grid(
  sample_id = unique(neut.data$sample_id),
  labels = unique(neut.data$labels),
  stringsAsFactors = FALSE
)

# Get metadata per sample
sample_metadata <- neut.data %>%
  dplyr::select(sample_id, donor, treatment, time_new) %>%
  distinct()

# Merge sample-cluster combos with metadata
all_combos <- all_combos %>%
  left_join(sample_metadata, by = "sample_id")

# Get cluster counts
cluster_counts <- neut.data %>%
  group_by(sample_id, donor, labels, treatment, time_new) %>%
  summarise(cluster_count = n(), .groups = "drop")

# Fill in missing combinations with 0s
cluster_counts <- all_combos %>%
  left_join(cluster_counts, by = c("sample_id", "donor", "labels", "treatment", "time_new")) %>%
  mutate(cluster_count = replace_na(cluster_count, 0))

total_cells <- neut.data %>%
  group_by(sample_id) %>%
  summarise(total_cells = n(), .groups = "drop")
counts_summary <- cluster_counts %>%
  left_join(total_cells, by = "sample_id")

clusters <- unique(counts_summary$labels)
```

### next i get the "delta" or relative/fold change
```{r}
delta_data <- counts_summary %>%
  group_by(donor, time_new) %>%
  mutate(prop = cluster_count / total_cells) %>%  # Proportion per cluster
  group_by(donor, labels) %>%
  mutate(
    baseline_prop = prop[time_new == "-72h"],  # or "-72h" if that's your baseline
    delta = prop / baseline_prop
  ) %>%
  ungroup()
```

## define function to loop the mixed model over each cluster
### the model is a lmer, accounting for paired samples where possible
### we then get the estimated means ande constrast results (basicalyy the p values)
```{r}
analyse_cluster <- function(cluster_name) {
  dat_clust <- delta_data %>% filter(labels == cluster_name)
  
  model <- tryCatch({
    lmer(
      delta ~ treatment * time_new + (1 | donor),
      data = dat_clust
    )
  }, error = function(e) {
    message(paste("Model failed for cluster", cluster_name))
    return(NULL)
  })
  
  if (is.null(model)) return(NULL)
  
  emm <- emmeans(model, ~ treatment | time_new, type = "response")
  contrasts <- contrast(emm, method = "pairwise")
  list(
    cluster = cluster_name,
    model_summary = summary(model),
    emmeans = emm,
    contrasts = contrasts
  )
}
```

## run the model and get the results
```{r}
results_list <- lapply(clusters, analyse_cluster)
names(results_list) <- clusters

# Filter out clusters where model failed (if any)
results_list <- results_list[!sapply(results_list, is.null)]

# Example: access contrasts for the first cluster
print(results_list[[1]]$contrasts)
```

## here we access the results list, pulling out the emmeans and contrasts with a function
## then combine into usable dataframes
```{r}
# Function to get EMMs + contrasts with p-values for plotting
extract_emm_and_contrasts <- function(cluster_name, results_list) {
  emm_df <- as.data.frame(results_list[[cluster_name]]$emmeans)
  contrasts_df <- as.data.frame(results_list[[cluster_name]]$contrasts)
  
  # Add cluster ID to both
  emm_df$cluster_id <- cluster_name
  contrasts_df$cluster_id <- cluster_name
  
  list(emm = emm_df, contrast = contrasts_df)
}

# Apply to all clusters
emm_contrast_list <- lapply(names(results_list), extract_emm_and_contrasts, results_list = results_list)

# Combine into data frames
emm_all <- bind_rows(lapply(emm_contrast_list, `[[`, "emm"))
contrast_all <- bind_rows(lapply(emm_contrast_list, `[[`, "contrast"))
```

## add a column specifying if a result was significant so that we can use these in the plot
## add a value that is above the upper confidence interval by a little bit so that the asterisks will sit above them on the plot
## join these columns back in witht he contrasts_all df
```{r}
# Extract timepoint and treatment comparison from contrast row names
contrast_all <- contrast_all %>%
  mutate(
    sig_label = case_when(
      p.value < 0.001 ~ "***",
      p.value < 0.01 ~ "**",
      p.value < 0.05 ~ "*",
      TRUE ~ ""
    )
  )

max_prob <- emm_all %>%
  group_by(cluster_id) %>%
  summarise(max_y = max(upper.CL, na.rm = TRUE)) %>%
  mutate(label_y = max_y +0.05)

contrast_all <- contrast_all %>%
  left_join(max_prob, by = "cluster_id")
```

## plot the results and save
```{r}
plot1 <- ggplot(emm_all, aes(x = time_new, y = emmean, colour = treatment, group = treatment)) +
  geom_hline(yintercept = 1, linetype = "dashed", colour = "grey50")+
  geom_line(position = position_dodge(width=0.4)) +
  geom_point(position = position_dodge(width=0.4)) +
  geom_errorbar(aes(ymin = lower.CL, ymax = upper.CL), width = 0.2,
  position = position_dodge(width=0.4)) +
  geom_text(
    data = contrast_all %>% filter(sig_label != ""),
    aes(x = time_new, y = label_y, label = sig_label),
    inherit.aes = FALSE,
    size = 7
  ) +
  facet_wrap(~cluster_id, scales = "free_y") +
  labs(
    title = "Relative change of cluster proportions over time",
    y = "Relative change",
    x = "Timepoint",
    colour = "Treatment"
  ) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))+scale_colour_manual(values=c("mediumseagreen", "darkorchid2"))+ 
  scale_y_continuous(expand = expansion(mult = c(0.05, 0.15)))+
  theme(axis.text = element_text(size = 12, colour = "black"),
  strip.text = element_text(size = 12, colour = "black", face = "bold"),
  axis.title = element_text(size = 14, colour = "black"))+ 
    theme(legend.text = element_text(size = 14),legend.title = element_text(size = 15))+
  guides(colour = guide_legend(override.aes = list(size = 5)))
plot1
#change name of plot if neuts are excluded
ggsave(plot=plot1,filename="relative_change_proportions.png", dpi = 500,
height = 8, width = 12, bg="white")
```

## assessing marker expression over time
### i will save the mixed model for specific markers/custers, otherwise its just too many to run and is fishing too strongly
### so beginning with a simple visualisations to assess overall changes
### i need to get average expression per donor to start with (right now every cell is represented)
```{r}
expression_input <- pivot_longer(neut.data, names_to = "marker", values_to="expression", 1:31)
exp_by_donor <- expression_input %>%
  group_by(donor, treatment, labels, marker, time_new) %>%
  summarise(median = median(expression, na.rm = TRUE), .groups = "drop")
exp_by_treatment <- expression_input %>%
  group_by(treatment, labels, marker, time_new) %>%
  summarise(median = median(expression, na.rm = TRUE), .groups = "drop")
```

## for the heatmap i need scaled expression, as ggplot wont do that
## trim the dataframe to only meaningful markers (e.g. don't care about cd4, cd8 ore neut marker expression changing), then plot heatmap
### i also split the visualisations into groups of cell types, as some markers arent applicable to all
```{r}
plot_input <- exp_by_treatment %>%
  pivot_wider(names_from = treatment, values_from = median) %>%
  mutate(diff = corona - guinness)
quant_limits <- quantile(plot_input$diff, probs = c(0.025, 0.975), na.rm = TRUE)
lower_limit <- quant_limits[1]
upper_limit <- quant_limits[2]

plot_input <- plot_input %>%
  mutate(diff_capped = pmin(pmax(diff, lower_limit), upper_limit))

plot_input <- filter(plot_input, !marker %in% c("CD45", "CD4", "CD8", "CD15", "CD66b", "CD3"), time_new %in% c("6h", "24h", "48h", "72h"))

t <- plot_input %>% filter(labels %in% c("CD4+T", "Treg", "Naive CD8+T", "Memory CD8+T", "T")) %>%
    filter(marker %in% c("TIGIT", "PD1", "KI67", "FOXP3", "CTLA4", "CD47", "CD69", "CD62L","CD39", "CD28",
    "CD25", "CD127", "CD103", "CCR6", "CXCR4", "CD1C", "GLUT1", "CXCR2"))
myeloid <- plot_input %>% filter(labels %in% c("Classical_mono", "Intermediate_mono", "Non_classical_mono", "DC")) %>%
    filter(marker %in% c("CD1c", "CD14", "CD16", "CCR6", "PD1", "CXCR4", "CD47", "CD86",
    "CD11b", "CD69", "HLA-DR", "KI67", ""))
ggplot(t, aes(x = time_new, y = marker, fill = diff))+geom_tile(colour = "black")+
    facet_wrap(~labels, ncol=11)+scale_fill_distiller(palette = "RdBu")
ggplot(myeloid, aes(x = time_new, y = marker, fill = diff))+geom_tile(colour = "black")+
    facet_wrap(~labels, ncol=11)+scale_fill_distiller(palette = "RdBu")
```

## further investigation and plotting of markers that look like they are changing
## i plot these with a longitudinal line plot to see if trends are promising, then will run the lmm on them and plot the estimated means 
```{r}
moi <- "CD11b"
t <- c("CD4+T", "Treg", "Naive CD8+T", "Memory CD8+T", "T")
myeloid <- c("Classical_mono", "Intermediate_mono", "Non_classical_mono", "DC")
model_input <- exp_by_donor %>%
  filter(labels %in% myeloid) %>%
  filter(marker == moi)
baseline_df <- model_input %>%
  filter(time_new == "-72h") %>%
  dplyr::select(donor, treatment, labels, marker, baseline = median)
model_input <- model_input %>%
  left_join(baseline_df, by = c("donor", "treatment", "labels", "marker"))

ggplot(model_input, aes(x = time_new, y = median, colour = treatment, group = treatment))+theme_bw()+
    stat_summary(fun=mean, geom = "point")+
    stat_summary(fun=mean, geom="line")+
    stat_summary(fun.data = mean_se, geom="errorbar", width = 0.2)+
    facet_wrap(~labels, scales="free_y")
```

```{r}
analyse_cluster <- function(cluster_name) {
  dat_clust <- model_input %>% filter(labels == cluster_name)
  
  model <- tryCatch({
    lmer(
      median ~ treatment * time_new + baseline + (1 | donor),
      data = dat_clust
    )
  }, error = function(e) {
    message(paste("Model failed for cluster", cluster_name))
    return(NULL)
  })
  
  if (is.null(model)) return(NULL)
  
  emm <- emmeans(model, ~ treatment | time_new, type = "response")
  contrasts <- contrast(emm, method = "pairwise")
  list(
    cluster = cluster_name,
    model_summary = summary(model),
    emmeans = emm,
    contrasts = contrasts
  )
}
```

## run the model and get the results
```{r}
results_list <- lapply(clusters, analyse_cluster)
names(results_list) <- clusters

# Filter out clusters where model failed (if any)
results_list <- results_list[!sapply(results_list, is.null)]

# Example: access contrasts for the first cluster
print(results_list[[1]]$contrasts)
```

## here we access the results list, pulling out the emmeans and contrasts with a function
## then combine into usable dataframes
```{r}
# Function to get EMMs + contrasts with p-values for plotting
extract_emm_and_contrasts <- function(cluster_name, results_list) {
  emm_df <- as.data.frame(results_list[[cluster_name]]$emmeans)
  contrasts_df <- as.data.frame(results_list[[cluster_name]]$contrasts)
  
  # Add cluster ID to both
  emm_df$cluster_id <- cluster_name
  contrasts_df$cluster_id <- cluster_name
  
  list(emm = emm_df, contrast = contrasts_df)
}

# Apply to all clusters
emm_contrast_list <- lapply(names(results_list), extract_emm_and_contrasts, results_list = results_list)

# Combine into data frames
emm_all <- bind_rows(lapply(emm_contrast_list, `[[`, "emm"))
contrast_all <- bind_rows(lapply(emm_contrast_list, `[[`, "contrast"))
```

## add a column specifying if a result was significant so that we can use these in the plot
## add a value that is above the upper confidence interval by a little bit so that the asterisks will sit above them on the plot
## join these columns back in witht he contrasts_all df
```{r}
# Extract timepoint and treatment comparison from contrast row names
contrast_all <- contrast_all %>%
  mutate(
    sig_label = case_when(
      p.value < 0.001 ~ "***",
      p.value < 0.01 ~ "**",
      p.value < 0.05 ~ "*",
      TRUE ~ ""
    )
  )

max_prob <- emm_all %>%
  group_by(cluster_id) %>%
  summarise(max_y = max(upper.CL, na.rm = TRUE)) %>%
  mutate(label_y = max_y +0.05)

contrast_all <- contrast_all %>%
  left_join(max_prob, by = "cluster_id")
```

## plot the results and save
```{r}
plot1 <- ggplot(emm_all, aes(x = time_new, y = emmean, colour = treatment, group = treatment)) +
  geom_line(position = position_dodge(width=0.4)) +
  geom_point(position = position_dodge(width=0.4)) +
  geom_errorbar(aes(ymin = lower.CL, ymax = upper.CL), width = 0.2,
  position = position_dodge(width=0.4)) +
  geom_text(
    data = contrast_all %>% filter(sig_label != ""),
    aes(x = time_new, y = label_y, label = sig_label),
    inherit.aes = FALSE,
    size = 7
  ) +
  facet_wrap(~cluster_id, scales = "free_y") +
  labs(
    title = paste0(moi," expression over time"),
    y = paste0(moi, " expression"),
    x = "Timepoint",
    colour = "Treatment"
  ) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))+scale_colour_manual(values=c("mediumseagreen", "darkorchid2"))+ 
  scale_y_continuous(expand = expansion(mult = c(0.05, 0.15)))+
  theme(axis.text = element_text(size = 12, colour = "black"),
  strip.text = element_text(size = 12, colour = "black", face = "bold"),
  axis.title = element_text(size = 14, colour = "black"))+ 
    theme(legend.text = element_text(size = 14),legend.title = element_text(size = 15))+
  guides(colour = guide_legend(override.aes = list(size = 5)))
plot1
#change name of plot if neuts are excluded
ggsave(plot=plot1,filename=paste0(moi,"_expression.png"), dpi = 500,
height = 8, width = 12, bg="white")
```