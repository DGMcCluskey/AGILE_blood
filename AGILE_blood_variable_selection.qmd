---
title: "Untitled"
format: html
---

## using machine learning approaches (sPLS-DA and randomforest) to indentify features that discriminate treatment arms at each timepont
```{r}
library(mixOmics)
library(dplyr)
library(tidyr)
library(patchwork)
library(ggplotify)
library(gganimate)
```


```{r}
setwd("c:/Users/dan_m/OneDrive - University College London/UCL_Senior_Research_Fellow/AGILE/Blood/sub_clustering")
blood_df <- readRDS("AGILE_blood_dataframe.rds")
```


```{r}
exp_by_donor <- blood_df %>% pivot_longer(names_to="marker", values_to="expression", cols=c(1:31))
exp_by_donor <- exp_by_donor %>% group_by(donor,time_new,treatment,marker) %>% summarise(median = median(expression), .groups="drop")
```

```{r}
top_markers_by_time <- list()
all_results <- data.frame()
timepoints <- unique(exp_by_donor$time_new)

for (tp in timepoints) {
  cat("Processing timepoint:", tp, "\n")
  
  marker_data_tp <- exp_by_donor %>%
    filter(time_new == tp) %>%
    dplyr::select(donor, treatment, marker, median) %>%
    pivot_wider(names_from = marker, values_from = median) %>%
    drop_na()
  
  X <- marker_data_tp %>% dplyr::select(-donor, -treatment) %>% as.matrix()
  Y <- factor(marker_data_tp$treatment)
  
  if (length(unique(Y)) < 2 || nrow(X) < 6) {
    warning(paste("Skipping", tp, "due to insufficient groups or donors"))
    next
  }

  # Run sPLS-DA
  splsda_res <- splsda(X, Y, ncomp = 2, keepX = 10)
  
  # OPTIONAL: Run performance evaluation
  perf_res <- perf(splsda_res, validation = "Mfold", folds = 5, progressBar = FALSE, nrepeat = 10)

  # Print performance
  cat("  Error rates (BER):", perf_res$error.rate$BER, "\n")

  # Save performance if needed
  # performance_by_time[[tp]] <- perf_res

  # Extract top markers
  top_vars <- selectVar(splsda_res, comp = 1)$name
  top_markers_by_time[[tp]] <- top_vars

  # Extract sample coordinates on components 1 and 2
    coords <- splsda_res$variates$X[, 1:2]
    
    # Build dataframe with embedding info
    emb_df <- data.frame(coords) %>%
      mutate(donor = marker_data_tp$donor,
             treatment = marker_data_tp$treatment,
             timepoint = tp)
    
    # Build dataframe for top markers
    top_markers_df <- data.frame(
      timepoint = tp,
      marker = top_vars,
      stringsAsFactors = FALSE
    )
    
    # Combine results
    # Here we keep embedding and top markers in separate dataframes but can store both
    # For example, bind top markers info to a cumulative dataframe:
    all_results <- bind_rows(all_results, emb_df)
    
    # Save plots as needed in a separate list (or save ggplot objects somewhere)
    # embedding_plots[[paste(tp, clust, sep = "_")]] <- plotIndiv(...)
    # loading_plots[[paste(tp, clust, sep = "_")]] <- plotLoadings(...)
  }

```

## plot the embeddings
### testing out an animated visualisation
```{r}
all_results$timepoint <- factor(all_results$timepoint, levels = c("-72h", "0h", "6h", "24h", "48h", "72h"))
anim_plot <- ggplot(all_results, aes(x = comp1, y = comp2, colour=treatment))+geom_point(size = 5)+
  labs(title = "Timepoint: {current_frame}") +
  ylim(-6,6)+xlim(-7,7)+
   ggforce::geom_mark_ellipse(aes(group = treatment), size = 2)+
  theme_bw()+#stat_ellipse()+
  scale_colour_manual(values=c("mediumseagreen","darkorchid2"))+transition_manual(timepoint)
anim <- animate(anim_plot, nframes=12, fps=1, renderer = gifski_renderer(), width=600, height=500, res=100)
anim
anim_save("splsda_animation.gif", animation = anim)
```

## run sPLS-DA on each cluster individually
```{r}
exp_by_donor <- blood_df %>%
  pivot_longer(names_to = "marker", values_to = "expression", cols = c(1:31)) %>%
  group_by(donor, time_new, treatment, marker, labels) %>%
  summarise(median = median(expression), .groups = "drop")

timepoints <- unique(exp_by_donor$time_new)

# Initialize an empty dataframe to hold all results
all_results <- data.frame()

for (tp in timepoints) {
  cat("Processing timepoint:", tp, "\n")
  
  clusters_in_tp <- unique(exp_by_donor$labels[exp_by_donor$time_new == tp])
  
  for (clust in clusters_in_tp) {
    cat("  Processing cluster:", clust, "\n")
    
    marker_data <- exp_by_donor %>%
      filter(time_new == tp, labels == clust) %>%
      select(donor, treatment, marker, median) %>%
      pivot_wider(names_from = marker, values_from = median) %>%
      drop_na()
    
    if (length(unique(marker_data$treatment)) < 2) {
      warning(paste("  Skipping cluster", clust, "at", tp, "- only one treatment group"))
      next
    }
    
    X <- marker_data %>% select(-donor, -treatment) %>% as.matrix()
    Y <- factor(marker_data$treatment)
    
    keepX <- 10
    
    splsda_res <- splsda(X, Y, ncomp = 2, keepX = keepX)
    
    # Get top markers from comp 1
    top_vars <- selectVar(splsda_res, comp = 1)$name
    
    # Extract sample coordinates on components 1 and 2
    coords <- splsda_res$variates$X[, 1:2]
    
    # Build dataframe with embedding info
    emb_df <- data.frame(coords) %>%
      mutate(donor = marker_data$donor,
             treatment = marker_data$treatment,
             timepoint = tp,
             cluster = clust)
    
    # Build dataframe for top markers
    top_markers_df <- data.frame(
      timepoint = tp,
      cluster = clust,
      marker = top_vars,
      stringsAsFactors = FALSE
    )
    
    # Combine results
    # Here we keep embedding and top markers in separate dataframes but can store both
    # For example, bind top markers info to a cumulative dataframe:
    all_results <- bind_rows(all_results, emb_df)
    
    # Save plots as needed in a separate list (or save ggplot objects somewhere)
    # embedding_plots[[paste(tp, clust, sep = "_")]] <- plotIndiv(...)
    # loading_plots[[paste(tp, clust, sep = "_")]] <- plotLoadings(...)
  }
}

print(all_results)

```

## plot results by celltype
```{r}
all_results$timepoint <- factor(all_results$timepoint, levels = c("-72h", "0h", "6h", "24h", "48h", "72h"))
ggplot(all_results, aes(x = comp1, y = comp2, colour=treatment))+geom_point()+
  facet_grid(~cluster)+theme_bw()+#stat_ellipse()+
  scale_colour_manual(values=c("mediumseagreen","darkorchid2"))

```