---
title: "Untitled"
format: html
---

## using machine learning approaches (sPLS-DA and randomforest) to indentify features that discriminate treatment arms at each timepont
```{r}
library(mixOmics)
library(dplyr)
library(tidyr)
library(patchwork)
library(ggplotify)
```


```{r}
setwd("c:/Users/dan_m/OneDrive - University College London/UCL_Senior_Research_Fellow/AGILE/Blood/sub_clustering")
blood_df <- readRDS("AGILE_blood_dataframe.rds")
```


```{r}
exp_by_donor <- blood_df %>% pivot_longer(names_to="marker", values_to="expression", cols=c(1:31))
exp_by_donor <- exp_by_donor %>% group_by(donor,time_new,treatment,marker) %>% summarise(median = median(expression), .groups="drop")
```

```{r}
# Load mixOmics
library(mixOmics)

loading_plots <- list()
embedding_plots <- list()

for (tp in timepoints) {
  cat("Processing timepoint:", tp, "\n")
  
  marker_data_tp <- exp_by_donor %>%
    filter(time_new == tp) %>%
    dplyr::select(donor, treatment, marker, median) %>%
    pivot_wider(names_from = marker, values_from = median) %>%
    drop_na()
  
  X <- marker_data_tp %>% dplyr::select(-donor, -treatment) %>% as.matrix()
  Y <- factor(marker_data_tp$treatment)
  
  if (length(unique(Y)) < 2 || nrow(X) < 6) {
    warning(paste("Skipping", tp, "due to insufficient groups or donors"))
    next
  }

  # Run sPLS-DA
  splsda_res <- splsda(X, Y, ncomp = 2, keepX = 10)
  
  # OPTIONAL: Run performance evaluation
  perf_res <- perf(splsda_res, validation = "Mfold", folds = 5, progressBar = FALSE, nrepeat = 10)

  # Print performance
  cat("  Error rates (BER):", perf_res$error.rate$BER, "\n")

  # Save performance if needed
  # performance_by_time[[tp]] <- perf_res

  # Extract top markers
  top_vars <- selectVar(splsda_res, comp = 1)$name
  top_markers_by_time[[tp]] <- top_vars

  # Plots
  p_embed <- plotIndiv(splsda_res, comp = c(1,2), group = Y, legend = TRUE,
                       title = paste("sPLS-DA:", tp),
                       ellipse = TRUE, star = F, cex = 2.5, pch = 16,
                       col=c("mediumseagreen", "darkorchid2"), style="ggplot2")
  
  plot_obj <- plotLoadings(splsda_res, comp = 1,
                           method = "mean", contrib = "max",
                           title = paste("Top markers at", tp),
                           legend.color = c("mediumseagreen", "darkorchid2"),
                           size.name = 2)

  embedding_plots[[tp]] <- p_embed
  loading_plots[[tp]] <- plot_obj
}
```

## plot the embeddings in markers in a nice grid
```{r}
ggplots_only <- lapply(embedding_plots, function(x) x$graph)
ggplots_only <- lapply(seq_along(ggplots_only), function(i) {
  if (i == length(ggplots_only)) {
    ggplots_only[[i]]  # keep legend
  } else {
    ggplots_only[[i]] + theme(legend.position = "none")
  }
})

# Combine them into one patchwork layout
combo1 <- wrap_plots(ggplots_only, ncol = 6)
combo1
ggsave(plot=combo1, filename = "spls-da_embeddings.png", dpi=500, height=5,width=18)
```

## run sPLS-DA on each cluster individually
```{r}
exp_by_donor <- blood_df %>% pivot_longer(names_to="marker", values_to="expression", cols=c(1:31))
exp_by_donor <- exp_by_donor %>% group_by(donor,time_new,treatment,marker,labels) %>% summarise(median = median(expression), .groups="drop")

# 1. Get all timepoints
timepoints <- unique(exp_by_donor$time_new)

# 2. Initialize output lists
top_markers_by_tp_clust <- list()
loading_plots <- list()
embedding_plots <- list()

# 3. Loop through each timepoint
for (tp in timepoints) {
  cat("Processing timepoint:", tp, "\n")
  
  # Get clusters present in this timepoint
  clusters_in_tp <- unique(exp_by_donor$labels[exp_by_donor$time_new == tp])
  
  # Loop through clusters within this timepoint
  for (clust in clusters_in_tp) {
    cat("  Processing cluster:", clust, "\n")
    
    # Filter for current timepoint and cluster
    marker_data <- exp_by_donor %>%
      filter(time_new == tp, labels == clust) %>%
      dplyr::select(donor, treatment, marker, median) %>%
      pivot_wider(names_from = marker, values_from = median)
    
    # Remove rows with NA (incomplete donor data)
    marker_data <- marker_data %>% drop_na()
    
    # Check there are at least 2 treatment groups
    if (length(unique(marker_data$treatment)) < 2) {
      warning(paste("  Skipping cluster", clust, "at", tp, "- only one treatment group"))
      next
    }
    
    # Prepare X and Y
    X <- marker_data %>% dplyr::select(-donor, -treatment) %>% as.matrix()
    Y <- factor(marker_data$treatment)
    
    # Set number of top markers to keep
    keepX <- 10
    
    # Run sPLS-DA
    splsda_res <- splsda(X, Y, ncomp = 2,keepX = keepX)
    
    # Extract top markers
    top_vars <- selectVar(splsda_res, comp = 1)$name
    
    # Use a compound key for the list (e.g., "TP1_Cluster5")
    key <- paste(tp, clust, sep = "_")
    top_markers_by_tp_clust[[key]] <- top_vars
    
    # Plot embeddings and loadings
    p_embed <- plotIndiv(splsda_res, comp = c(1,2), group = Y, legend = TRUE,
                         title = paste("sPLS-DA: Time", tp, "| Cluster", clust),
                         ellipse = TRUE, star = FALSE, cex = 2.5, pch = 16,
                         col=c("mediumseagreen", "darkorchid2"), style="ggplot2")
    
    plot_obj <- plotLoadings(splsda_res, comp = 1,
                             method = "mean", contrib = "max",
                             title = paste("Top markers: Time", tp, "| Cluster", clust),
                             legend.color = c("mediumseagreen", "darkorchid2"),
                             size.name = 2)
    
    # Save plots
    embedding_plots[[key]] <- p_embed
    loading_plots[[key]] <- plot_obj
  }
}

# 4. Combine top markers into a dataframe
top_markers_df <- stack(top_markers_by_tp_clust) %>%
  rename(marker = values, tp_cluster = ind) %>%
  tidyr::separate(tp_cluster, into = c("timepoint", "cluster"), sep = "_")

print(top_markers_df)
```

## plot results by celltype
```{r}
plots <- lapply(embedding_plots, function(x) x$graph)
treg <- plots$`-72h_Treg`+plots$`0h_Treg`+plots$`6h_Treg`+plots$`24h_Treg`+plots$`48h_Treg`+plots$`72h_Treg`
treg
b <- plots$`-72h_B`+plots$`0h_B`+plots$`6h_B`+plots$`24h_B`+plots$`48h_B`+plots$`72h_B`
b
nk <- plots$`-72h_NK`+plots$`0h_NK`+plots$`6h_NK`+plots$`24h_NK`+plots$`48h_NK`+plots$`72h_NK`
nk
cd4t <- plots$`-72h_CD4+T`+plots$`0h_CD4+T`+plots$`6h_CD4+T`+plots$`24h_CD4+T`+plots$`48h_CD4+T`+plots$`72h_CD4+T`
cd4t
dc <- plots$`-72h_DC`+plots$`0h_DC`+plots$`6h_DC`+plots$`24h_DC`+plots$`48h_DC`+plots$`72h_DC`
dc
classical_mono <- plots$`72h_Classical_mono`+plots$`0h_Classical_mono`+plots$`6h_Classical_mono`+plots$`24h_Classical_mono`+plots$`48h_Classical_mono`+plots$`72h_Classical_mono`
classical_mono

```