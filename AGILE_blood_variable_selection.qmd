---
title: "Untitled"
format: html
---

## using machine learning approaches (sPLS-DA and randomforest) to indentify features that discriminate treatment arms at each timepont
```{r}
library(mixOmics)
library(dplyr)
library(tidyr)
library(patchwork)
library(ggplotify)
library(gganimate)
```


```{r}
setwd("c:/Users/dan_m/OneDrive - University College London/UCL_Senior_Research_Fellow/AGILE/Blood/sub_clustering")
blood_df <- readRDS("AGILE_blood_dataframe.rds")
```


```{r}
exp_by_donor <- blood_df %>% pivot_longer(names_to="marker", values_to="expression", cols=c(1:31))
exp_by_donor <- exp_by_donor %>% group_by(donor,time_new,treatment,marker) %>% summarise(median = median(expression), .groups="drop")
```

```{r}
loading_plots <- list()
embedding_plots <- list()
top_markers_by_time <- list()

timepoints <- unique(exp_by_donor$time_new)

for (tp in timepoints) {
  cat("Processing timepoint:", tp, "\n")
  
  marker_data_tp <- exp_by_donor %>%
    filter(time_new == tp) %>%
    dplyr::select(donor, treatment, marker, median) %>%
    pivot_wider(names_from = marker, values_from = median) %>%
    drop_na()
  
  X <- marker_data_tp %>% dplyr::select(-donor, -treatment) %>% as.matrix()
  Y <- factor(marker_data_tp$treatment)
  
  if (length(unique(Y)) < 2 || nrow(X) < 6) {
    warning(paste("Skipping", tp, "due to insufficient groups or donors"))
    next
  }

  # Run sPLS-DA
  splsda_res <- splsda(X, Y, ncomp = 2, keepX = 10)
  
  # OPTIONAL: Run performance evaluation
  perf_res <- perf(splsda_res, validation = "Mfold", folds = 5, progressBar = FALSE, nrepeat = 10)

  # Print performance
  cat("  Error rates (BER):", perf_res$error.rate$BER, "\n")

  # Save performance if needed
  # performance_by_time[[tp]] <- perf_res

  # Extract top markers
  top_vars <- selectVar(splsda_res, comp = 1)$name
  top_markers_by_time[[tp]] <- top_vars

  # Plots
  p_embed <- plotIndiv(splsda_res, comp = c(1,2), group = Y, legend = TRUE,
                       title = paste("sPLS-DA:", tp),
                       ellipse = TRUE, star = F, cex = 2.5, pch = 16,
                       col=c("mediumseagreen", "darkorchid2"), style="ggplot2")
  
  plot_obj <- plotLoadings(splsda_res, comp = 1,
                           method = "mean", contrib = "max",
                           title = paste("Top markers at", tp),
                           legend.color = c("mediumseagreen", "darkorchid2"),
                           size.name = 2)

  embedding_plots[[tp]] <- p_embed
  loading_plots[[tp]] <- plot_obj
}
```

## plot the embeddings in markers in a nice grid
```{r}
ggplots_only <- lapply(embedding_plots, function(x) x$graph)
ggplots_only <- lapply(seq_along(ggplots_only), function(i) {
  if (i == length(ggplots_only)) {
    ggplots_only[[i]]  # keep legend
  } else {
    ggplots_only[[i]] + theme(legend.position = "none")
  }
})

# Combine them into one patchwork layout
combo1 <- wrap_plots(ggplots_only, ncol = 6)
combo1
ggsave(plot=combo1, filename = "spls-da_embeddings.png", dpi=500, height=5,width=18)
```

## run sPLS-DA on each cluster individually
```{r}
exp_by_donor <- blood_df %>%
  pivot_longer(names_to = "marker", values_to = "expression", cols = c(1:31)) %>%
  group_by(donor, time_new, treatment, marker, labels) %>%
  summarise(median = median(expression), .groups = "drop")

timepoints <- unique(exp_by_donor$time_new)

# Initialize an empty dataframe to hold all results
all_results <- data.frame()

for (tp in timepoints) {
  cat("Processing timepoint:", tp, "\n")
  
  clusters_in_tp <- unique(exp_by_donor$labels[exp_by_donor$time_new == tp])
  
  for (clust in clusters_in_tp) {
    cat("  Processing cluster:", clust, "\n")
    
    marker_data <- exp_by_donor %>%
      filter(time_new == tp, labels == clust) %>%
      select(donor, treatment, marker, median) %>%
      pivot_wider(names_from = marker, values_from = median) %>%
      drop_na()
    
    if (length(unique(marker_data$treatment)) < 2) {
      warning(paste("  Skipping cluster", clust, "at", tp, "- only one treatment group"))
      next
    }
    
    X <- marker_data %>% select(-donor, -treatment) %>% as.matrix()
    Y <- factor(marker_data$treatment)
    
    keepX <- 10
    
    splsda_res <- splsda(X, Y, ncomp = 2, keepX = keepX)
    
    # Get top markers from comp 1
    top_vars <- selectVar(splsda_res, comp = 1)$name
    
    # Extract sample coordinates on components 1 and 2
    coords <- splsda_res$variates$X[, 1:2]
    
    # Build dataframe with embedding info
    emb_df <- data.frame(coords) %>%
      mutate(donor = marker_data$donor,
             treatment = marker_data$treatment,
             timepoint = tp,
             cluster = clust)
    
    # Build dataframe for top markers
    top_markers_df <- data.frame(
      timepoint = tp,
      cluster = clust,
      marker = top_vars,
      stringsAsFactors = FALSE
    )
    
    # Combine results
    # Here we keep embedding and top markers in separate dataframes but can store both
    # For example, bind top markers info to a cumulative dataframe:
    all_results <- bind_rows(all_results, emb_df)
    
    # Save plots as needed in a separate list (or save ggplot objects somewhere)
    # embedding_plots[[paste(tp, clust, sep = "_")]] <- plotIndiv(...)
    # loading_plots[[paste(tp, clust, sep = "_")]] <- plotLoadings(...)
  }
}

print(all_results)

```

## plot results by celltype
```{r}
all_results$timepoint <- factor(all_results$timepoint, levels = c("-72h", "0h", "6h", "24h", "48h", "72h"))
anim_plot <- ggplot(all_results, aes(x = comp1, y = comp2, colour=treatment))+geom_point()+
  facet_grid(~cluster)+theme_bw()+#stat_ellipse()+
  scale_colour_manual(values=c("mediumseagreen","darkorchid2"))+transition_states(timepoint, transition_length = 2, state_length = 1)
animate(anim_plot)
anim_save("splsda_animation.gif", animation = last_animation())

```