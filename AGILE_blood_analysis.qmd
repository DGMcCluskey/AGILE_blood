---
title: "Untitled"
format: html
---

### Analysis of the blood data from the AGILE trial
### analysis is blinded, with treatments named "guinness" and "corona"
```{r}
library(CATALYST)
library(harmony)
library(cowplot)
library(flowCore)
library(scater)
library(SingleCellExperiment)
library(viridis)
library(RColorBrewer)
library(ggforce)
library(ggplot2)
library(ggrepel)
library(ggsci)
library(data.table)
library(emmeans)
library(dplyr)
library(tidyr)
library(ggsignif)
library(rstatix)
library(multcomp)
library(scales)
library(ggthemes)
library(slingshot)
library(ggbeeswarm)
library(ggbreak)
library(DescTools)
library(pak)
library(gghighlight)
library(scattermore)
library(clustree)
library(gridExtra)
library(patchwork)
library(ggbump)
library(stringr)
library(grid)
library(lme4)
library(emmeans)
library(purrr)
library(randomcoloR)
```

```{r}
"c:/Users/dan_m/OneDrive - University College London/UCL_Senior_Research_Fellow/AGILE/Blood"
```

## loads in FCS files and create flowset object
### list fcs files in folder, choose ones requied and then run read.flowset
```{r}
fcs <- list.files(pattern = ".fcs$")
fcs
fs <- read.flowSet(fcs, transformation = F, truncate_max_range = F)
```


## setting up flourophore information
### check columns (fluorophores) and remove any not needed
### when running for the first time, save the columns into an excel to form the basis of the fluorophore metadata
### if this has been created before, just load it in
```{r}
all_cols <- colnames(fs)
all_cols
fs <- fs[,-c(1,2,31,35)]
colnames(fs)
cols <- colnames(fs)
cols <- as.data.frame(cols)
#write.csv(cols, file = "Marker.metadata.csv")
markers <- read.csv("Marker.metadata.csv")
markers
```

## setting up sample metadata
### use the file names as the basis for the sample metadata
### first add a column to make the sample id (removes excess characters at end of each fcs file name)
#### more specifically, this drops the last 18 characters (which are the redundant parts of the file name)
### use separate to add individual metadata features - due to "stained_blood" being in the naame, i tell this to become "drop" (because i'll remove it) and "tissue"
## if script run previously then just load it in
```{r}
names <- data.frame(fcs)
sample_df <- names %>% mutate(sample_id = str_sub(fcs, 1, nchar(fcs)-18))
sample_df <- separate(sample_df, col = sample_id, into = c("treatment", "donor", "drop", "tissue", "time"), remove = F, sep = "_")
sample_df <- sample_df[, c(-5)]
#write.csv(sample_df, file = "sample.metadata.csv")
samples <- read.csv("sample.metadata.csv")
samples <- samples[-1]
```

## making the singlecellexperiment object
### double check flourophore and sample_ids match their respective metadata files
### use prepdata to make the sce - here cofactors can be set, which are assessed afterwards
### this step is repeated until final cofactors are decided
```{r}
setdiff(colnames(fs), markers$fluorophore)
setdiff(fcs, samples$fcs)

sce <- prepData(x = fs, panel = markers, md = samples, FACS = T, transform = T, 
  cofactor = c("AF647-A"=1000,"APC-Cy7-A"=2000,"APC-Fire810-A"=1000,"BUV395-A"=1000,"BUV496-A"=2000,"BUV563-A"=700,"BUV737-A"=1000,"BUV805-A"=1000,"BV421-A"=1000,"BV480-A"=2000,"BV605-A"=1000,"BV711-A"=1000,"BV750-A"=1000,"BV785-A"=1000,"FITC-A"=1000,"PE-A"=2000,"PE-Cy5-A"=1000,"PE-Cy7-A"=1000,"PE-Fire810-A"=1000,"R718-A"=1000,"RB545-A"=1000,"RB744-A"=1000,"RB780-A"=1000,"SB645-A"=1000,"SBB580-A"=1000,"SBUV605-A"=1000,"SBV570-A"=1000,"V450-A"=1000,"[RB613]-A"=1000,"[RB705]-A"=1000,"[RY610]-A"=1000), 
  panel_cols = list(channel = "fluorophore", antigen = "antigen"),
  md_cols = list(file = "fcs", id = "sample_id",
  factors = c("donor", "treatment", "tissue", "time")))
```

## downsampling
### there is ~13 million cells, which is far more than necessary and is computationally limiting
### therefore downsampling to 5% of cells, applied to each sample individually
### this function is straight from chatgpt, but seems to work well
```{r}
downsample <- function(sce, sample_col = "sample_id", proportion = 0.05, min_cells = 10) {
  # Get sample labels
  samples <- colData(sce)[[sample_col]]
  
  # For each sample, randomly select proportion of cells
  selected_cells <- unlist(lapply(unique(samples), function(s) {
    cells_in_sample <- which(samples == s)
    n <- max(round(length(cells_in_sample) * proportion), min_cells)  # enforce a minimum
    n <- min(length(cells_in_sample), n)  # avoid oversampling
    sample(cells_in_sample, n)
  }))
  
  # Subset the SCE to those cells
  sce_downsampled <- sce[, selected_cells]
  return(sce_downsampled)
}
numbers_before <- table(sce$sample_id)
sce <- downsample(sce, sample_col = "sample_id", proportion = 0.05)
numbers_after <- table(sce$sample_id)
```
## assess cofactors
### check how many cells in experiment to get an idea of computational load
### assess cofactors - looking for negative peak to be around 0 whilst maintaining a separation from positive peak
### there is a level of subjectivity
```{r}
table(sce$treatment)
plotExprs(sce, color_by = "donor")
```

## Batch correction
### use the harmony package to apply batch correction - using donor as the correction
```{r}
expdata <- sce@assays@data$exprs
meta <- sce@colData$donor
expdata <- t(expdata)
nrow(expdata)
nrow(meta)
harmony_output <- HarmonyMatrix(expdata, meta_data = meta, do_pca = F)
sce@assays@data$uncorrected <- sce@assays@data$exprs
sce@assays@data$exprs <- t(harmony_output)
```
## clustering
## run the clustering and assess elbow plot - this will determine appropriate k number for selecting resolution
```{r}
set.seed(61)
sce <- CATALYST::cluster(sce, features = NULL, xdim = 10, ydim = 10, maxK = 30, verbose = T, seed = 61)

delta <- delta_area(sce)
delta <- delta$data
ggplot(delta, aes(x = k, y = y))+geom_point(size = 5)+geom_line(linewidth = 1.5)+
  theme_classic()+
  theme(axis.text = element_text(colour = "black", size = 18), 
        axis.title = element_text(size = 18, colour = "black"))+
  xlab("K (number of clusters)")+ylab("Relative change in \n area under CDF curve")

```

### create umap
```{r}
sce <- runDR(sce, "UMAP", features = NULL)
```

## save/load here
```{r}
#saveRDS(sce, file = "agile_blood_clustered.rds", compress = F)
sce <- readRDS("agile_blood_clustered.rds")
```

## inspect umap by metadata - this will confirm absence of batch effects and generally view how groups behave
```{r}
variables <- c("donor", "treatment", "time")
umaps <- list()
for (i in variables) {
umaps[[i]] <- plotDR(sce, "UMAP", color_by = i)+theme_bw()+
    geom_scattermore()
} 
p <- plot_grid(umaps$donor, umaps$treatment, umaps$time)
p
```

## if it looks reasonable (i.e doesn't split by donor, suggesting batche effect) start assessing the resolution (also known as meta or k)
### here i use the previously generated delta plot to get an idea of what an appropriate k might be - i then also "over-cluster" on purpose

```{r}
res <- c("meta10", "meta15", "meta20", "meta25")
umaps <- list()

for (i in res) {
umaps[[i]] <- plotDR(sce, "UMAP", color_by = i)+theme_bw()+
    geom_scattermore()
} 

p1 <- plot_grid(umaps$meta10, umaps$meta15, umaps$meta20, umaps$meta25)
p1

ggsave(plot = p1, filename = "umaps_resolution_comparison.png", dpi = 500,
height = 6, width = 16)
```

## i also plot the expression of all markers in the umap. whilst this is computationally intensive and takes a while, it is worth it as it allows us to see if a marker is expressed across clusters or is distinct to one cluster
```{r}
markers.input <- markers$antigen
p2 <- plotDR(sce, color_by = markers.input)+theme_bw()
ggsave(plot = p2, filename = "umap_all_markers.png", dpi = 500,
height = 16, width = 16, bg = "white")
```

## plotting specific k of interest
```{r}
p1 <- plotDR(sce, color_by = "meta20")+theme_bw()
p1
p2 <- plotDR(sce, color_by = "meta20")+facet_wrap(~meta20)+theme_bw()
p2
p3 <- plotExprHeatmap(sce, k = "meta20", by = "cluster_id", bars = TRUE, perc = TRUE)
p3
```

## filtering and annotation
### the main point at this stage is to get some preliminary labels that can be further assessed
### first i also remove tiny clusters that have no expression of a distinct phenotype - likely derbis, doublets or cells that didnt stain properly
### in this case, this is only clusters 8 and 9, which are both < 1% of all cells and lack any distinctive marker expression
```{r}
sce <- filterSCE(sce, k = "meta20", cluster_id %in% c("1", "2", "3", "4", "6", "7","10", "11", "12",
"13", "14", "15", "16", "17", "18", "19", "20"))
merging.table <- data.frame("original" = c(1,2,3,4,5,6,7,10,11,12,13,14,15,16,17,18,19,20), 
"labels" = c("neutrophil", "neutrophil", "neutrophil", "classical_mono", "neutrophil", "neutrophil", "NK", "CD4+T", "CD4+T", "T", "CD8+T", "non_classical_mono", "classical_mono", "DC", "DC", "CD4+T","CD8+T","B"))

sce <- mergeClusters(sce, k = "meta20", table = merging.table, id = "labels", overwrite = T)

sce$labels <- cluster_ids(sce, k = "labels")
```
## extract data for plotting
### before full annotation, we will briefly assess if treatment/time affect cluster proportions
### add chosen k as a metadata column so that this can be used (add more here if required)
### then we pull out the data and make it into a dataframe, which is then easy to use for plotting
```{r}
sce$k20 <- cluster_ids(sce, "meta20")

ex <- assay(sce, "exprs")
neut.data <- data.frame(t(ex), sample_id = sce$sample_id, donor = sce$donor, 
                        treatment = sce$treatment, time = sce$time, 
                        k20 = sce$k20, labels = sce$labels)
#add umap dimensions
umap.coords <- data.frame(reducedDim(sce, "UMAP"))
neut.data$UMAP_1 <- umap.coords$UMAP1
neut.data$UMAP_2 <- umap.coords$UMAP2
neut.data$labels <- factor(neut.data$labels, levels =c("CD4+T", "CD8+T", "T", "NK", "B",
"classical_mono", "non_classical_mono", "DC", "neutrophil"))
```

## annotated umaps and accompanying heatmap
```{r}
label_data <- neut.data %>%
  group_by(labels) %>%
  summarise(UMAP_1 = median(UMAP_1), UMAP_2 = median(UMAP_2), .groups = "drop")

plot1 <-ggplot(neut.data, aes(x=UMAP_1,y=UMAP_2,colour=labels))+geom_point(size = 0.5)+
  theme_half_open()+
  scale_colour_manual(values = c("indianred2", "red", "darkred", "darkorchid2", "orange",
  "steelblue2", "blue", "cyan4", "mediumseagreen"))+
    geom_label_repel(data=label_data, aes(label=labels, fill = labels), colour = "white",
    size = 5, fontface = "bold", label.size = 1)+
    scale_fill_manual(values = c("indianred2", "red", "darkred", "darkorchid2", "orange",
  "steelblue2", "blue", "cyan4", "mediumseagreen"))+
    theme(legend.position = "none")
plot1

ggplot(neut.data, aes(x=UMAP_1,y=UMAP_2,colour=treatment))+geom_scattermore()+
  theme_half_open()+
  scale_colour_manual(values = c("mediumseagreen", "darkorchid2"))+
  theme(
    legend.position = c(0.95, 0.20),
    legend.justification = c(1, 1),
    legend.background = element_rect(fill = "white"),
    legend.title = element_text(size = 16),
    legend.text = element_text(size = 14)
  )

ggplot(neut.data, aes(x=UMAP_1,y=UMAP_2,colour=time))+geom_scattermore()+
  theme_half_open()+
  scale_colour_manual(values = c("black", "grey50", "darkred", "red", "darkorchid2", "steelblue2", "blue"))+
  theme(
    legend.position = c(0.95, 0.40),
    legend.justification = c(1, 1),
    legend.background = element_rect(fill = "white"),
    legend.title = element_text(size = 16),
    legend.text = element_text(size = 14)
  )

random_palette <- distinctColorPalette(18)
ggplot(neut.data, aes(x=UMAP_1,y=UMAP_2,colour=donor))+geom_scattermore()+
  theme_half_open()+
  scale_colour_manual(values=random_palette)+
  theme(
    legend.position = c(0.96, 0.30),
    legend.justification = c(1, 1),
    legend.background = element_rect(fill = "white"),
    legend.title = element_text(size = 16),
    legend.text = element_text(size = 14)
  )+guides(colour=guide_legend(ncol=3))


```
## cluster proportions
### a few samples have a 4hr time, these will be called 6h here for analysis sake, but acknowledged throughout
### before i run differential abundance, i want to just see the proportions of each cluster in total across the dataset
```{r}
neut.data$time_new <- factor(neut.data$time, levels = c("-72h", "0h", "4h", "6h", "24h", "48h", "72h"),
labels = c("-72h", "0h", "6h", "6h", "24h", "48h", "72h"))
proportions <- neut.data %>% group_by(labels, time_new) %>% dplyr::count(labels,time_new)
proportions <- pivot_wider(proportions, names_from = labels, values_from = n)
proportions[is.na(proportions)] <- 0
proportions$total = rowSums(proportions[, c(2:10)])
proportions <- pivot_longer(proportions, names_to = "cluster", values_to = "number", 2:10)
proportions$prop <- (proportions$number/proportions$total)*100
p1 <- ggplot(proportions, aes(x = time_new, y = prop, fill = cluster))+
  geom_col()+theme_bw()+
  theme(axis.text = element_text(size = 12, colour = "black"))+theme(strip.text=element_text(size = 14, colour = "black", face = "bold"))+
  scale_fill_brewer(palette = "Paired")+
  scale_y_continuous(expand = c(0,0))
p1
ggsave(plot=p1, filename = "cluster_proportions_barplot.png", dpi = 500, height = 14, width = 4)
```

## differential abundance analysis
### set data up for mixed-effects model
### here im getting counts per cluster, total cells per sample, then a summary
### next i get the "delta" or relative/fold change
```{r}
cluster_counts <- neut.data %>%
  group_by(sample_id,donor, labels, treatment, time_new) %>%
  summarise(cluster_count = n(), .groups = "drop")
total_cells <- neut.data %>%
  group_by(sample_id) %>%
  summarise(total_cells = n(), .groups = "drop")
counts_summary <- cluster_counts %>%
  left_join(total_cells, by = "sample_id")

clusters <- unique(counts_summary$labels)

delta_data <- counts_summary %>%
  group_by(donor, time_new) %>%
  mutate(prop = cluster_count / total_cells) %>%  # Proportion per cluster
  group_by(donor, labels) %>%
  mutate(
    baseline_prop = prop[time_new == "-72h"],  # or "-72h" if that's your baseline
    delta = prop / baseline_prop
  ) %>%
  ungroup()
```

## define function to loop the mixed model over each cluster
### the model is a lmer, accounting for paired samples where possible
### we then get the estimated means ande constrast results (basicalyy the p values)
```{r}
analyse_cluster <- function(cluster_name) {
  dat_clust <- delta_data %>% filter(labels == cluster_name)
  
  model <- tryCatch({
    lmer(
      delta ~ treatment * time_new + (1 | donor),
      data = dat_clust
    )
  }, error = function(e) {
    message(paste("Model failed for cluster", cluster_name))
    return(NULL)
  })
  
  if (is.null(model)) return(NULL)
  
  emm <- emmeans(model, ~ treatment | time_new, type = "response")
  contrasts <- contrast(emm, method = "pairwise")
  list(
    cluster = cluster_name,
    model_summary = summary(model),
    emmeans = emm,
    contrasts = contrasts
  )
}
```

## run the model and get the results
```{r}
results_list <- lapply(clusters, analyse_cluster)
names(results_list) <- clusters

# Filter out clusters where model failed (if any)
results_list <- results_list[!sapply(results_list, is.null)]

# Example: access contrasts for the first cluster
print(results_list[[1]]$contrasts)
```

## here we access the results list, pulling out the emmeans and contrasts with a function
## then combine into usable dataframes
```{r}
# Function to get EMMs + contrasts with p-values for plotting
extract_emm_and_contrasts <- function(cluster_name, results_list) {
  emm_df <- as.data.frame(results_list[[cluster_name]]$emmeans)
  contrasts_df <- as.data.frame(results_list[[cluster_name]]$contrasts)
  
  # Add cluster ID to both
  emm_df$cluster_id <- cluster_name
  contrasts_df$cluster_id <- cluster_name
  
  list(emm = emm_df, contrast = contrasts_df)
}

# Apply to all clusters
emm_contrast_list <- lapply(names(results_list), extract_emm_and_contrasts, results_list = results_list)

# Combine into data frames
emm_all <- bind_rows(lapply(emm_contrast_list, `[[`, "emm"))
contrast_all <- bind_rows(lapply(emm_contrast_list, `[[`, "contrast"))
```

## add a column specifying if a result was significant so that we can use these in the plot
## add a value that is above the upper confidence interval by a little bit so that the asterisks will sit above them on the plot
## join these columns back in witht he contrasts_all df
```{r}
# Extract timepoint and treatment comparison from contrast row names
contrast_all <- contrast_all %>%
  mutate(
    sig_label = case_when(
      p.value < 0.001 ~ "***",
      p.value < 0.01 ~ "**",
      p.value < 0.05 ~ "*",
      TRUE ~ ""
    )
  )

max_prob <- emm_all %>%
  group_by(cluster_id) %>%
  summarise(max_y = max(upper.CL, na.rm = TRUE)) %>%
  mutate(label_y = max_y +0.05)

contrast_all <- contrast_all %>%
  left_join(max_prob, by = "cluster_id")
```

## plot the results and save
```{r}
plot1 <- ggplot(emm_all, aes(x = time_new, y = emmean, colour = treatment, group = treatment)) +
  geom_hline(yintercept = 1, linetype = "dashed", colour = "grey50")+
  geom_line(position = position_dodge(width=0.4)) +
  geom_point(position = position_dodge(width=0.4)) +
  geom_errorbar(aes(ymin = lower.CL, ymax = upper.CL), width = 0.2,
  position = position_dodge(width=0.4)) +
  geom_text(
    data = contrast_all %>% filter(sig_label != ""),
    aes(x = time_new, y = label_y, label = sig_label),
    inherit.aes = FALSE,
    size = 7
  ) +
  facet_wrap(~cluster_id, scales = "free_y") +
  labs(
    title = "Relative change of cluster proportions over time",
    y = "Relative change",
    x = "Timepoint",
    colour = "Treatment"
  ) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))+scale_colour_manual(values=c("mediumseagreen", "darkorchid2"))+ 
  scale_y_continuous(expand = expansion(mult = c(0.05, 0.15)))+
  theme(axis.text = element_text(size = 12, colour = "black"),
  strip.text = element_text(size = 12, colour = "black", face = "bold"),
  axis.title = element_text(size = 14, colour = "black"))+ 
    theme(legend.text = element_text(size = 14),legend.title = element_text(size = 15))+
  guides(colour = guide_legend(override.aes = list(size = 5)))
plot1
ggsave(plot=plot1,filename="relative_change_proportions.png", dpi = 500,
height = 8, width = 12, bg="white")
```